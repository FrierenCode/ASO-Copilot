# 3. Scoring Package 구현 결과

## 개요

`packages/scoring` 워크스페이스 패키지를 신규 생성하고,
룰 기반 채점 엔진 `scoreCopy()`를 구현하여 `apps/api` `/generate` 엔드포인트에 연동한 작업 결과입니다.

---

## 1) 변경한 파일 목록

| 작업 | 파일 |
|------|------|
| CREATE | `packages/scoring/package.json` |
| CREATE | `packages/scoring/tsconfig.json` |
| CREATE | `packages/scoring/src/scoreCopy.ts` |
| CREATE | `packages/scoring/src/index.ts` |
| EDIT | `apps/api/package.json` |
| EDIT | `apps/api/src/index.ts` |
| EDIT | `apps/api/test/index.spec.ts` |

---

## 2) 각 파일 최종 코드

### `packages/scoring/package.json`

```json
{
  "name": "@aso-copilot/scoring",
  "version": "0.0.0",
  "private": true,
  "type": "module",
  "exports": {
    ".": "./src/index.ts"
  },
  "dependencies": {
    "@aso-copilot/shared": "workspace:*"
  }
}
```

---

### `packages/scoring/tsconfig.json`

```json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "noEmit": true
  },
  "include": ["src/**/*.ts"]
}
```

---

### `packages/scoring/src/scoreCopy.ts`

```typescript
import type { GenerateRequest } from '@aso-copilot/shared'

export interface ScoreBreakdown {
  cta: number
  benefit: number
  clarity: number
  numeric: number
  emotion: number
}

export interface ScoreCopyResult {
  score: number
  breakdown: ScoreBreakdown
  recommendation: string[]
}

const CTA_KEYWORDS = ['download', 'get', 'start', 'try', 'now', 'free', 'join', 'unlock']
const BENEFIT_KEYWORDS = ['save', 'easy', 'fast', 'improve', 'boost', 'productivity', 'growth']
const EMOTION_KEYWORDS = ['amazing', 'love', 'powerful', 'effortless', 'confident']

function clamp(value: number, min: number, max: number): number {
  return Math.min(Math.max(value, min), max)
}

function countKeywords(corpus: string, keywords: string[]): number {
  return keywords.reduce((count, kw) => {
    const regex = new RegExp(`\\b${kw}\\b`, 'gi')
    return count + (corpus.match(regex)?.length ?? 0)
  }, 0)
}

export function scoreCopy(input: GenerateRequest): ScoreCopyResult {
  const corpus = [input.appName, input.category, input.screenshots.join(' ')]
    .join(' ')
    .toLowerCase()

  // CTA: count CTA keywords, each contributes 5 points
  const ctaCount = countKeywords(corpus, CTA_KEYWORDS)
  const cta = clamp(ctaCount * 5, 0, 20)

  // Benefit: count benefit keywords, each contributes 5 points
  const benefitCount = countKeywords(corpus, BENEFIT_KEYWORDS)
  const benefit = clamp(benefitCount * 5, 0, 20)

  // Clarity: base 16, penalize too-short/too-long copy and noisy punctuation
  const words = corpus.trim().split(/\s+/).filter(Boolean)
  let clarity = 16
  if (words.length < 5) clarity -= 8
  if (words.length > 50) clarity -= 4
  const punctuationMatches = corpus.match(/[!?]/g) ?? []
  const excessPunctuation = Math.max(0, punctuationMatches.length - 1)
  clarity -= excessPunctuation * 2
  clarity = clamp(clarity, 0, 20)

  // Numeric: detect digits/percentages/stat-like patterns
  const numericMatches = corpus.match(/\d+[%x+]?/g) ?? []
  const numeric = clamp(numericMatches.length * 5, 0, 20)

  // Emotion: count emotional words, each contributes 5 points
  const emotionCount = countKeywords(corpus, EMOTION_KEYWORDS)
  const emotion = clamp(emotionCount * 5, 0, 20)

  const breakdown: ScoreBreakdown = { cta, benefit, clarity, numeric, emotion }
  const score = Math.round(cta + benefit + clarity + numeric + emotion)

  const recommendation: string[] = []
  if (cta < 12) recommendation.push('Add a clear CTA keyword (e.g. "Get", "Start", "Try free")')
  if (benefit < 12) recommendation.push('Highlight a user benefit (e.g. "Save time", "Boost productivity")')
  if (clarity < 12) recommendation.push('Simplify copy: aim for 5–50 words, avoid excessive punctuation')
  if (numeric < 12) recommendation.push('Add a numeric proof point (e.g. "10x faster", "50% off")')
  if (emotion < 12) recommendation.push('Use emotional language (e.g. "Powerful", "Effortless", "Confident")')

  if (recommendation.length === 0) {
    recommendation.push('Great copy! Keep testing variations to maintain performance.')
  }

  return { score, breakdown, recommendation }
}
```

#### 채점 로직 설계

| 차원 | 키워드 | 점수 계산 | 범위 |
|------|--------|-----------|------|
| `cta` | download, get, start, try, now, free, join, unlock | 매치 수 × 5 | 0..20 |
| `benefit` | save, easy, fast, improve, boost, productivity, growth | 매치 수 × 5 | 0..20 |
| `clarity` | — | base 16, 단어 수 < 5 이면 −8, > 50 이면 −4, 과도한 `!?` 1개 초과 시 −2/개 | 0..20 |
| `numeric` | 숫자·퍼센트·배수 패턴 (`\d+[%x+]?`) | 매치 수 × 5 | 0..20 |
| `emotion` | amazing, love, powerful, effortless, confident | 매치 수 × 5 | 0..20 |

- **corpus**: `appName + category + screenshots.join(" ")` 소문자 정규화
- **총점**: 5개 차원 합산, `Math.round()` → 0..100
- **권장사항**: 차원 점수 < 12 이면 해당 차원별 구체적 액션 추가, 모든 차원 ≥ 12 이면 유지 권고문 1개 추가

---

### `packages/scoring/src/index.ts`

```typescript
export { scoreCopy } from './scoreCopy'
export type { ScoreBreakdown, ScoreCopyResult } from './scoreCopy'
```

---

### `apps/api/package.json`

```json
{
  "name": "api",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    "deploy": "wrangler deploy",
    "dev": "wrangler dev",
    "start": "wrangler dev",
    "test": "vitest",
    "cf-typegen": "wrangler types"
  },
  "devDependencies": {
    "@cloudflare/vitest-pool-workers": "^0.12.4",
    "@types/node": "^20.19.35",
    "typescript": "^5.5.2",
    "vitest": "~3.2.0",
    "wrangler": "^4.69.0"
  },
  "dependencies": {
    "@aso-copilot/scoring": "workspace:*",
    "@aso-copilot/shared": "workspace:*",
    "hono": "^4.12.3"
  }
}
```

---

### `apps/api/src/index.ts`

```typescript
import { Hono } from 'hono'
import {
  GenerateRequestSchema,
  GenerateResponseSchema,
  type GenerateRequest,
  type GenerateResponse,
} from '@aso-copilot/shared'
import { scoreCopy } from '@aso-copilot/scoring'

const app = new Hono()

// Health check
app.get('/health', (c) => {
  return c.json({
    ok: true,
    service: 'api',
  })
})

// Generate endpoint
app.post('/generate', async (c) => {
  let body: unknown

  try {
    body = await c.req.json()
  } catch {
    return c.json(
      { ok: false, error: 'Invalid JSON' },
      400
    )
  }

  const parsed = GenerateRequestSchema.safeParse(body)

  if (!parsed.success) {
    return c.json(
      { ok: false, error: parsed.error.flatten() },
      400
    )
  }

  const request: GenerateRequest = parsed.data
  const scoring = scoreCopy(parsed.data)

  const response: GenerateResponse = {
    variants: {
      A: [`${request.appName} A1`, `${request.appName} A2`],
      B: [`${request.category} B1`, `${request.category} B2`],
      C: ['C1', 'C2'],
    },
    score: scoring.score,
    recommendation: scoring.recommendation,
  }

  GenerateResponseSchema.parse(response)

  return c.json(response)
})

// 404 handler
app.notFound((c) => {
  return c.json(
    { ok: false, error: 'Not Found' },
    404
  )
})

export default app
```

---

### `apps/api/test/index.spec.ts`

```typescript
import { describe, it, expect } from 'vitest'
import app from '../src/index'
import { createExecutionContext, waitOnExecutionContext } from 'cloudflare:test'

describe('API Routes', () => {
  it('health', async () => {
    const req = new Request('http://localhost/health')
    const ctx = createExecutionContext()
    const res = await app.fetch(req, {}, ctx)
    await waitOnExecutionContext(ctx)

    expect(res.status).toBe(200)

    const data = await res.json()
    expect(data.ok).toBe(true)
    expect(data.service).toBe('api')
  })

  it('generate success', async () => {
    const req = new Request('http://localhost/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        appName: 'Test App',
        category: 'Productivity',
        screenshots: [
          's1.png',
          's2.png',
          's3.png',
          's4.png',
          's5.png',
          's6.png',
        ],
      }),
    })

    const ctx = createExecutionContext()
    const res = await app.fetch(req, {}, ctx)
    await waitOnExecutionContext(ctx)

    expect(res.status).toBe(200)

    const data = await res.json()
    expect(data.variants).toBeDefined()
    expect(data.variants.A.length).toBeGreaterThan(0)
    expect(data.variants.B.length).toBeGreaterThan(0)
    expect(data.variants.C.length).toBeGreaterThan(0)
    expect(typeof data.score).toBe('number')
    expect(data.score).toBeGreaterThanOrEqual(0)
    expect(data.score).toBeLessThanOrEqual(100)
    expect(Array.isArray(data.recommendation)).toBe(true)
    expect(data.recommendation.length).toBeGreaterThan(0)
  })

  it('generate validation error', async () => {
    const req = new Request('http://localhost/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        appName: 'Test App',
        category: 'Productivity',
        screenshots: ['s1.png', 's2.png'],
      }),
    })

    const ctx = createExecutionContext()
    const res = await app.fetch(req, {}, ctx)
    await waitOnExecutionContext(ctx)

    expect(res.status).toBe(400)

    const data = await res.json()
    expect(data.ok).toBe(false)
    expect(data.error).toBeDefined()
    expect(data.error.fieldErrors).toBeDefined()
    expect(data.error.fieldErrors.screenshots).toBeDefined()
  })
})
```

---

## 3) 테스트 결과

```
pnpm -C apps/api test -- --run

 RUN  v3.2.4

 ✓ test/index.spec.ts (3 tests) 38ms

 Test Files  1 passed (1)
       Tests  3 passed (3)
    Duration  1.91s
```

| 테스트 케이스 | 결과 |
|---|---|
| `health` | ✅ PASS |
| `generate success` | ✅ PASS |
| `generate validation error` | ✅ PASS |

---

## 4) `npm run dev` 실제 동작 확인

### GET /health

```
curl http://localhost:8787/health
```

```json
{ "ok": true, "service": "api" }
```

---

### POST /generate — 키워드 풍부한 케이스

**요청**

```json
{
  "appName": "FitTrack Pro",
  "category": "Health & Fitness",
  "screenshots": [
    "Start your free 30-day trial now",
    "Save 2 hours every week effortlessly",
    "Join 1 million confident users",
    "Boost your productivity 3x faster",
    "Amazing results, powerful tracking",
    "Download today and unlock your goals"
  ]
}
```

**응답**

```json
{
  "variants": {
    "A": ["FitTrack Pro A1", "FitTrack Pro A2"],
    "B": ["Health & Fitness B1", "Health & Fitness B2"],
    "C": ["C1", "C2"]
  },
  "score": 86,
  "recommendation": [
    "Great copy! Keep testing variations to maintain performance."
  ]
}
```

> score 86: CTA(start/free/now/join/download/unlock), benefit(save/boost/productivity), clarity 양호, numeric(30/1/3/), emotion(effortlessly→effortless/confident/amazing/powerful) 전 차원 ≥ 12

---

### POST /generate — 키워드 없는 약한 케이스

**요청**

```json
{
  "appName": "MyApp",
  "category": "Utilities",
  "screenshots": ["screen1.png","screen2.png","screen3.png","screen4.png","screen5.png","screen6.png"]
}
```

**응답**

```json
{
  "variants": {
    "A": ["MyApp A1", "MyApp A2"],
    "B": ["Utilities B1", "Utilities B2"],
    "C": ["C1", "C2"]
  },
  "score": 36,
  "recommendation": [
    "Add a clear CTA keyword (e.g. \"Get\", \"Start\", \"Try free\")",
    "Highlight a user benefit (e.g. \"Save time\", \"Boost productivity\")",
    "Use emotional language (e.g. \"Powerful\", \"Effortless\", \"Confident\")"
  ]
}
```

> score 36: clarity 16(기본) + numeric 20(파일명 숫자 1~6 검출) + benefit 5(productivity 미해당, 0) = cta 0 + benefit 0 + clarity 16 + numeric 20 + emotion 0

---

### POST /generate — Validation Error (screenshots 부족)

**요청**

```json
{
  "appName": "MyApp",
  "category": "Utilities",
  "screenshots": ["screen1.png", "screen2.png"]
}
```

**응답 (HTTP 400)**

```json
{
  "ok": false,
  "error": {
    "formErrors": [],
    "fieldErrors": {
      "screenshots": ["Array must contain exactly 6 element(s)"]
    }
  }
}
```

---

## 5) 아키텍처 흐름

```
POST /generate
    │
    ├─ JSON 파싱 실패 → 400 { ok: false, error: "Invalid JSON" }
    │
    ├─ GenerateRequestSchema.safeParse()
    │       └─ 실패 → 400 { ok: false, error: { fieldErrors } }
    │
    ├─ scoreCopy(parsed.data)          ← @aso-copilot/scoring
    │       ├─ corpus 정규화
    │       ├─ 5개 차원 룰 기반 채점
    │       └─ ScoreCopyResult { score, breakdown, recommendation }
    │
    ├─ GenerateResponse 조립
    │       ├─ variants: (MVP 더미)
    │       ├─ score: scoring.score
    │       └─ recommendation: scoring.recommendation
    │
    ├─ GenerateResponseSchema.parse() 검증
    │
    └─ 200 { variants, score, recommendation }
```

---

## 6) 제약 사항 준수 확인

| 제약 | 준수 여부 |
|------|-----------|
| `GenerateRequest`를 `@aso-copilot/shared`에서 재사용 | ✅ |
| `/generate` 요청 검증 흐름 유지 | ✅ |
| `GenerateResponse` 계약 변경 없음 | ✅ |
| 결정론적 룰 기반 로직만 사용 (난수 없음) | ✅ |
